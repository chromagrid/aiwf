{
  "name": "AIWF â€¢ Semantic Select (Embeddings) v11",
  "nodes": [
    { "id": "start", "name": "Start", "type": "n8n-nodes-base.start", "typeVersion": 1, "position": [200, 220] },

    {
      "id": "plan",
      "name": "Plan & Cache Keys",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "const enabled=String($json.enabled||'false').toLowerCase()==='true';\nconst model=$json.embedding_model||$env.EMBED_MODEL||'openai/text-embedding-3-small';\nconst id2=$json.id2pattern||{};\nconst limit=Number($json.__embed_cap ?? $env.EMBED_CATALOG_CAP ?? 50);\nconst items=Object.values(id2).slice(0, limit);\nfunction textOf(p){ return `${p.id} :: ${(p.description||'')} :: ${(p.tags||[]).join(',')}`; }\nconst toHash=items.map(p=>({ id:p.id, hash:Buffer.from(textOf(p)).toString('base64').slice(0,64), text:textOf(p) }));\nreturn [{ json: { ...$json, _embed: { enabled, model, items: toHash } } }];"
      },
      "position": [420, 220]
    },

    {
      "id": "gateEnabled",
      "name": "Enabled?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "parameters": { "conditions": { "conditions": [ { "leftValue": "={{ $json._embed.enabled }}", "rightValue": "={{ true }}", "operator": { "type": "boolean", "operation": "isTrue" } } ] } },
      "position": [620, 220]
    },

    {
      "id": "redis_mget",
      "name": "Redis MGET vecs (pipeline)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "parameters": {
        "url": "={{ $env.REDIS_REST_URL && ($env.REDIS_REST_URL + '/pipeline') }}",
        "method": "POST",
        "jsonParameters": true,
        "sendHeaders": true,
        "headerParameters": { "parameters": [ { "name": "Authorization", "value": "={{ 'Bearer ' + $env.REDIS_REST_TOKEN }}" } ] },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "pipeline",
              "value": "={{ (function(){ const m=$json._embed.model; const cmds=[]; for(const it of ($json._embed.items||[])){cmds.push(['GET', `aiwf:embed:${m}:${it.id}`]);} return cmds; })() }}"
            }
          ]
        }
      },
      "position": [820, 220],
      "continueOnFail": true
    },

    {
      "id": "fill",
      "name": "Find Missing + Build Inputs",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "const model=$json._embed.model;\nconst items=$json._embed.items||[];\nconst res=$json.results||[];\nconst cached={};\nfor(let i=0;i<items.length;i++){\n  const raw=res?.[i]?.result; if(raw){ try{ const obj=JSON.parse(raw); if(Array.isArray(obj.vec) && obj.hash===items[i].hash) cached[items[i].id]=obj.vec; }catch{} }\n}\nconst budget=Number($env.EMBED_BUDGET_MAX||32);\nconst missingAll=items.filter(it=>!cached[it.id]);\nconst missing=missingAll.slice(0, Math.max(0, budget-1)); // leave 1 for query\nconst input=[ $json.q, ...missing.map(it=>it.text) ];\nreturn [{ json: { ...$json, _embed: { ...$json._embed, cached, missing, input } } }];"
      },
      "position": [1040, 220]
    },

    {
      "id": "embeds",
      "name": "Embeddings (OpenRouter)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "parameters": {
        "url": "https://openrouter.ai/api/v1/embeddings",
        "method": "POST",
        "jsonParameters": true,
        "sendHeaders": true,
        "headerParameters": { "parameters": [ { "name": "Authorization", "value": "={{ 'Bearer ' + $env.OPENROUTER_API_KEY }}" }, { "name": "Content-Type", "value": "application/json" } ] },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            { "name": "model", "value": "={{ $json._embed.model }}" },
            { "name": "input", "value": "={{ $json._embed.input || [$json.q] }}" }
          ]
        },
        "options": { "bodyContentType": "json", "timeout": 20000, "retryOnFail": true, "maxRetries": 1 }
      },
      "position": [1260, 200],
      "continueOnFail": true
    },

    {
      "id": "merge",
      "name": "Merge & Score",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "function cos(a,b){let d=0,na=0,nb=0;for(let i=0;i<a.length;i++){d+=a[i]*b[i];na+=a[i]*a[i];nb+=b[i]*b[i];}return d/(Math.sqrt(na)*Math.sqrt(nb)+1e-9);} \nconst data=$json.data||[];\nconst missing=$json._embed.missing||[];\nconst cached=$json._embed.cached||{};\nlet qv=[];\nif(Array.isArray(data)&&data.length>0){\n  qv=data[0]?.embedding||[];\n  for(let i=0;i<missing.length;i++){\n    const vec=data[i+1]?.embedding||[];\n    if(vec.length){ cached[missing[i].id]=vec; }\n  }\n}\nconst dim = qv.length;\nconst items=$json._embed.items||[];\nconst scores=[];\nfor(const it of items){ const v=cached[it.id]; if(Array.isArray(v) && (dim===0 || v.length===dim)) scores.push({id:it.id,score:cos(qv,v)}); }\nscores.sort((a,b)=>b.score-a.score);\nreturn [{ json: { ...$json, semantic_top: scores.slice(0,5), _embed: { ...$json._embed, cached } } }];"
      },
      "position": [1480, 200]
    },

    {
      "id": "redis_set",
      "name": "Redis SET Missing vecs (pipeline)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "parameters": {
        "url": "={{ $env.REDIS_REST_URL && ($env.REDIS_REST_URL + '/pipeline') }}",
        "method": "POST",
        "jsonParameters": true,
        "sendHeaders": true,
        "headerParameters": { "parameters": [ { "name": "Authorization", "value": "={{ 'Bearer ' + $env.REDIS_REST_TOKEN }}" } ] },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "pipeline",
              "value": "={{ (function(){ const m=$json._embed.model; const cmds=[]; for(const it of ($json._embed.items||[])){ const vec=$json._embed.cached[it.id]; if(Array.isArray(vec)){ const payload=JSON.stringify({hash:it.hash,vec}); cmds.push(['SET',`aiwf:embed:${m}:${it.id}`, payload]); cmds.push(['EXPIRE',`aiwf:embed:${m}:${it.id}`, 86400]); } } return cmds; })() }}"
            }
          ]
        }
      },
      "position": [1700, 200],
      "continueOnFail": true
    },

    { "id": "ret", "name": "Return", "type": "n8n-nodes-base.returnJson", "typeVersion": 1, "position": [1900, 200] }
  ],
  "connections": {
    "Start": { "main": [[{ "node": "Plan & Cache Keys", "type": "main", "index": 0 }]] },
    "Plan & Cache Keys": { "main": [[{ "node": "Enabled?", "type": "main", "index": 0 }]] },
    "Enabled?": {
      "main": [
        [{ "node": "Redis MGET vecs (pipeline)", "type": "main", "index": 0 }],
        [{ "node": "Return", "type": "main", "index": 0 }]
      ]
    },
    "Redis MGET vecs (pipeline)": { "main": [[{ "node": "Find Missing + Build Inputs", "type": "main", "index": 0 }]] },
    "Find Missing + Build Inputs": { "main": [[{ "node": "Embeddings (OpenRouter)", "type": "main", "index": 0 }]] },
    "Embeddings (OpenRouter)": { "main": [[{ "node": "Merge & Score", "type": "main", "index": 0 }]] },
    "Merge & Score": { "main": [[{ "node": "Redis SET Missing vecs (pipeline)", "type": "main", "index": 0 }, { "node": "Return", "type": "main", "index": 0 }]] },
    "Redis SET Missing vecs (pipeline)": { "main": [[{ "node": "Return", "type": "main", "index": 0 }]] }
  },
  "active": true
}
